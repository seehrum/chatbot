import csv
import os
import random
from typing import Dict, List, Optional
import Levenshtein
import logging

# Constants
SIMILARITY_THRESHOLD = 0.7
DATA_FILE = 'ai_data.csv'
MAX_ATTEMPTS = 3  # Maximum attempts for file operations

# Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def main():
    ai_dictionary = load_ai_data(DATA_FILE)

    while True:
        choice = get_user_choice()
        if choice == '1':
            train_ai_loop(ai_dictionary)
            save_ai_data(ai_dictionary, DATA_FILE)
        elif choice == '2':
            ask_ai_loop(ai_dictionary)
        elif choice == '3':
            break
        else:
            print("Invalid choice. Please try again.")

def get_user_choice() -> str:
    """Displays the main menu and returns the user's choice."""
    menu = "\nAI Assistant\n1. Train AI\n2. Ask AI\n3. Exit"
    print(menu)
    return input("Choose an option: ").strip()

def load_ai_data(filepath: str) -> Dict[str, List[str]]:
    """Loads AI data from a CSV file. Returns a dictionary with questions and answers."""
    attempts = 0
    while attempts < MAX_ATTEMPTS:
        try:
            if not os.path.exists(filepath):
                logging.info(f"File {filepath} not found. Starting with an empty dictionary.")
                return {}

            with open(filepath, mode='r', encoding='utf-8') as file:
                reader = csv.reader(file)
                return {row[0].lower(): row[1].split('|') for row in reader if len(row) == 2}
        except IOError as e:
            logging.error(f"IOError loading data: {e}")
            attempts += 1
        except Exception as e:
            logging.error(f"Unexpected error loading data: {e}")
            return {}

def save_ai_data(dictionary: Dict[str, List[str]], filepath: str):
    """Saves AI data to a CSV file."""
    attempts = 0
    while attempts < MAX_ATTEMPTS:
        try:
            with open(filepath, mode='w', encoding='utf-8', newline='') as file:
                writer = csv.writer(file)
                for question, answers in dictionary.items():
                    writer.writerow([question, '|'.join(answers)])
                break
        except IOError as e:
            logging.error(f"IOError saving data: {e}")
            attempts += 1
        except Exception as e:
            logging.error(f"Unexpected error saving data: {e}")

def train_ai_loop(dictionary: Dict[str, List[str]]):
    """Handles the loop for training the AI."""
    while True:
        question = get_training_question()
        if question == 'menu':
            break
        answer = get_training_answer()
        if answer:
            dictionary.setdefault(question, []).append(answer)
            print("Training complete.")

def get_training_question() -> str:
    """Gets a training question from the user."""
    return input("Enter the question (or type 'menu' to return to main menu): ").lower().strip()

def get_training_answer() -> Optional[str]:
    """Gets an answer for training from the user."""
    answer = input("Enter the answer: ").strip()
    if not answer:
        print("Answer cannot be empty.")
        return None
    return answer

def ask_ai_loop(dictionary: Dict[str, List[str]]):
    """Handles the loop for asking questions to the AI."""
    while True:
        user_question = get_user_question()
        if user_question == 'menu':
            break

        closest_match = find_closest_match(user_question, dictionary)
        if closest_match:
            answer = random.choice(dictionary[closest_match])
            print(f"AI: {answer}")
        else:
            print("AI: I don't know the answer to that. Please train me.")

def get_user_question() -> str:
    """Gets a question from the user for the AI."""
    return input("What is your question? (or type 'menu' to return to main menu): ").lower().strip()

def find_closest_match(user_question: str, dictionary: Dict[str, List[str]]) -> Optional[str]:
    """Finds the closest match for a user question from the trained data."""
    highest_similarity = SIMILARITY_THRESHOLD
    closest_match = None

    for trained_question in dictionary:
        similarity = Levenshtein.ratio(user_question, trained_question)
        if similarity > highest_similarity:
            highest_similarity = similarity
            closest_match = trained_question

    return closest_match if highest_similarity > SIMILARITY_THRESHOLD else None

if __name__ == "__main__":
    main()
